/*

backend.js
-   Server operations for Logical Reconfiguration Interface
    -   Serve web pages, as generated by React
    -   Handle MQTT Communications with PLCs


Joe Hicks | pmyjeh | 14189098
2020-12-17
The University of Nottingham

*/

// Import libraries
import mqtt from "mqtt"
import express from "express"
import WebSocket from "ws"
import fs from "fs"

// Import from config file
import { wsType, webPort, wsPort, defaultSequence } from "./src/config.js"
import argTypes from "./src/argtypes.js"

// Setup file to store data
const dataFile = "./data.csv"
if (!fs.existsSync(dataFile)) {
    fs.writeFileSync(dataFile, "time,barcode,depth\n")
}

//
// MQTT operations
//

// Connect to MQTT broker
const mqttAddress = "localhost"
const client = mqtt.connect(`mqtt://${mqttAddress}`)

// Declare symbols for MQTT topics for easier reuse
const topics = {
    resetDepth: "dt_reset_depth",
    requestDepth: "dt_request_depth",
    reportDepth: "dt_report_depth",
    barcodeRead: "bs_barcode_read",
    controlSiemens: "ctl_siemens",
    controlBeckhoff: "ctl_beckhoff",
    processNumbers: "pd_process_numbers",
    recordData: "rec_record_data",
    updateSequence: "ctl_update_sequence",
}

// Declare an array of the topics to subscribe to
const subscriptions = [
    topics.reportDepth,
    topics.processNumbers,
    topics.barcodeRead,
    topics.recordData,
]

// Once connection to MQTT broker is established, subscribe to the required topics
client.on("connect", function () {
    for (const sub of subscriptions) {
        client.subscribe(sub)
    }
})

// Variables to hold process data
let process = 0
let step = 0

// Handle incoming messages
client.on("message", function (topic, message) {
    // Decide what to do based on the received topic
    switch (topic.toString()) {
        case topics.reportDepth:
            console.log(`Depth reported: ${message.readUInt32LE()}`)
            break
        case topics.processNumbers:
            process = message.readInt16LE(0)
            step = message.readInt16LE(2)

            wss.clients.forEach((client) => {
                client.send(
                    createMessage(wsType.UPDATE, {
                        process: process,
                        step: step,
                    })
                )
            })
            break
        case topics.barcodeRead:
            console.log(`Barcode changed: ${message.toString()}`)
            break
        // Request to record data
        case topics.recordData:
            // Ingest data from packet
            const barcode = message.toString("utf-8", 0, 8)
            const depth = message.readUInt32LE(8)
            console.log(
                `Saving depth reading of ${depth} for barcode: ${barcode}`
            )
            // Add to the data file
            fs.appendFileSync(
                "./data.csv",
                `${new Date().toISOString()},${barcode},${depth}\n`
            )
            break
        default:
            break
    }
})

//
// Express app - webserving
//

// Declare an Express app
const app = express()

// Serve production React app
app.use(express.static("./build"))

app.listen(webPort, () => {
    console.log(`Backend server up on port ${webPort}`)
})

// Step Siemens process forward
app.get("/step", (req, res) => {
    client.publish("ctl_step", Buffer.from([1]))
    res.send("ok")
})

// Test function to push update
app.get("/prog", (req, res) => {
    const prog = fs.readFileSync("./newprog.hex")
    client.publish(topics.updateSequence, prog)
    console.log(prog)
    res.send("ok")
})

//
// Maintaining sequence in memory and on disk
//

let sequence = defaultSequence || []

if (fs.existsSync("./sequence.json")) {
    try {
        const diskSeq = JSON.parse("./sequence.json")
        sequence = diskSeq
    } catch (e) {}
}

//
// Websocket server - realtime communication with interface
//

// Start Websocket
const wss = new WebSocket.Server({
    port: wsPort,
})

// Function to build a message to send over WS
const createMessage = (type, data) =>
    JSON.stringify({
        type: type,
        ...data,
    })

// Run when a new Websocket connection is established
wss.on("connection", (ws) => {
    // Send the sequence
    ws.send(
        createMessage(wsType.NODEUPDATE, {
            sequence: sequence,
        })
    )

    // Handle incoming messages
    ws.on("message", (message) => {
        // Attempt to parse message as JSON
        try {
            message = JSON.parse(message)
        } catch (e) {
            return console.log(
                "Garbled message received:",
                message,
                " | Could not parse JSON | ",
                e
            )
        }
        // Handle message based on type
        switch (message.type) {
            case argTypes.SAVENODES:
                if (!!message.sequence) {
                    sequence = message.sequence
                    fs.writeFileSync("./sequence.json", JSON.stringify(message.sequence))
                }
                break
            default:
                break
        }
    })
})
