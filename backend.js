/*

backend.js
-   Server operations for Logical Reconfiguration Interface
    -   Serve web pages, as generated by React
    -   Handle MQTT Communications with PLCs


Joe Hicks | pmyjeh | 14189098
2020-12-17
The University of Nottingham

*/

// Import libraries
import mqtt from "mqtt"
import express from "express"
import WebSocket from "ws"
import fs from "fs"

// Import from config file
import { wsType, webPort, wsPort } from "./src/config.js"

// Setup file to store data
const dataFile = "./data.csv"
if (!fs.existsSync(dataFile)) {
    fs.writeFileSync(dataFile, "time,barcode,depth\n")
}

//
// MQTT operations
//

// Connect to MQTT broker
const mqttAddress = "localhost"
const client = mqtt.connect(`mqtt://${mqttAddress}`)

// Declare symbols for MQTT topics for easier reuse
const topics = {
    resetDepth: "dt_reset_depth",
    requestDepth: "dt_request_depth",
    reportDepth: "dt_report_depth",
    barcodeRead: "bs_barcode_read",
    controlSiemens: "ctl_siemens",
    controlBeckhoff: "ctl_beckhoff",
    processNumbers: "pd_process_numbers",
    recordData: "rec_record_data",
    updateSequence: "ctl_update_sequence"
}

// Declare an array of the topics to subscribe to
const subscriptions = [
    topics.reportDepth,
    topics.processNumbers,
    topics.barcodeRead,
    topics.recordData,
]

// Once connection to MQTT broker is established, subscribe to the required topics
client.on("connect", function () {
    for (const sub of subscriptions) {
        client.subscribe(sub)
    }
})

// Variables to hold process data
let process = 0
let step = 0

const createMessage = (type, data) =>
    JSON.stringify({
        type: type,
        ...data,
    })

// Handle incoming messages
client.on("message", function (topic, message) {
    // Decide what to do based on the received topic
    switch (topic.toString()) {
        case topics.reportDepth:
            console.log(`Depth reported: ${message.readUInt32LE()}`)
            break
        case topics.processNumbers:
            process = message.readInt16LE(0)
            step = message.readInt16LE(2)

            wss.clients.forEach((client) => {
                client.send(
                    createMessage(wsType.UPDATE, {
                        process: process,
                        step: step,
                    })
                )
            })
            break
        case topics.barcodeRead:
            console.log(`Barcode changed: ${message.toString()}`)
            break
        // Request to record data
        case topics.recordData:
            // Ingest data from packet
            const barcode = message.toString("utf-8", 0, 8)
            const depth = message.readUInt32LE(8)
            console.log(`Saving depth reading of ${depth} for barcode: ${barcode}`)
            // Add to the data file
            fs.appendFileSync("./data.csv", `${new Date().toISOString()},${barcode},${depth}\n`)
            break
        default:
            break
    }
})

//
// Express app - webserving
//

// Declare an Express app
const app = express()

// Serve production React app
app.use(express.static("./build"))

app.listen(webPort, () => {
    console.log(`Backend server up on port ${webPort}`)
})

// Step Siemens process forward
app.get("/step", (req, res) => {
    client.publish("ctl_step", Buffer.from([1]))
    res.send("ok")
})

// Test function to push update
app.get("/prog", (req, res) => {
    const prog = fs.readFileSync("./prog.hex")
    client.publish(topics.updateSequence, prog)
    console.log(prog)
    res.send("ok")
})

//
// Websocket server - realtime communication with interface
//

// Start Websocket
const wss = new WebSocket.Server({
    port: wsPort,
})

// Run when a new Websocket connection is established
wss.on("connection", (ws) => {
    // Send an update packet with the current process ID & step
    ws.send(
        createMessage(wsType.UPDATE, {
            process: process,
            step: step,
        })
    )
})
